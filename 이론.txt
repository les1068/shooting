변수 : 변하는 숫자. 필요한 데이터를 기록하는 곳
	데이터 타입
	int - 32bit 크기의 정수형(소수점 없는 숫자) 데이터 타입. (-21억~21억)
	float - 32bit 크기의 실수형(소수점 있는 숫자) 데이터 타입. 구조적으로 오차가 있는 데이터 타입이다.
	bool - 1bit 크기의 bool형. true 아니면 false만 가진다.
	string - 문자열을 기록하는 데이터 타입. 크기가 정해져 있지 않다. 변경 불가능한 데이터 타입이다.

접근 제한자(Access Modifier)
    private      : 자기 자신만 접근할 수 있다.
    protected  : 자신과 자신을 상속받은 대상만 접근할 수 있다.
    public       : 모두가 접근 할 수 있다.

부모와 자식 클래스
	public class DumpTruck : Car{}
	Car는 DumpTruck의 부모 클래스
	DumpTruck은 Car의 자식 클래스(파생 클래스)

제어문 : 조건문(if), 반복문(for)

디버거 단축키
F5 : 디버그 시작. 브레이크 포인트에서 계속 진행하기
F9 : 브레이크 포인트 설정
F10 : 한 줄씩 진행하기
F11 : 한 줄씩 진행하기 + 함수면 함수 안으로 들어가기

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★벡터 : 힘의 방향과 크기를 나타내는데 사용
★단위벡터(Unit Vector) : 힘의 방향만 표현하는 벡터. 크기가 *항상 1이다. 벡터를 정규화 해서 만들 수 있다.(Normalized)
★노멀벡터 : 특정 평면에 수직인 벡터. 반사를 계산하는데 *필수. 겉면과 안쪽면을 구분할 수 있게 해준다.

★벡터의 내적(Dot Product) : 벡터와 벡터를 내적했을 때 결과는 *스칼라로 계산된다.
  백터의 내적을 이용해서 두 벡터의 사이각을 구할 수 있다.

★벡터의 외적(Croos Product) : 투 벡터가 이루는 평면에 *수직인 벡터를 계산할 수 있다.
  삼각형의 앞면과 뒷면을 구분할 수 있게 해준다.

카메라가 삼각형을 그릴지 말지를 판단하는 방법은 카메라의 forward 벡터와 삼각형의 
normal벡터의 사이각을 계산해서 예각(0~90도)이면 그리지 않고 둔각이면(90~180도)이면 그린다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★행렬 :  숫자를 행(Row)과 열(Column)을 나누어서 표현한 것.
         행렬과 행렬의 곱은 행렬이 나온다.
         행렬은 *교환법칙이 성립하지 않는다.

Transform(변환) : 위치, 회전, 스케일을 한번에 표현한 것
	          행렬로 표현한다. (변환 행렬)
                      4 * 4 행렬을 사용

단위행렬 : I로 표현(대문자 i)
             대부분의 수는 0이고 왼쪽 위에서 오른쪽 아래로 가는 대각선 부부만 1이다.
             곱하더라도 곱해지는 대상은 항상 변하지 않는다. 
	 단위행렬은 교환법칙이 성립된다.

역행렬 :    -1
           M 
           행렬 M이 있을 때 M과 M의 역행렬을 곱하면 단위행렬이 나온다.

★이동행렬(Translate Matrix)
                         
		 x y z
	            (1,2,3만큼 움직이는 행렬)
	1 0 0 x       1001 ( 0 )     1*(0) + 0*(0) + 0*(0) + 1*(1) = 1 
	0 1 0 y   =  0102 ( 0 )  = 0*(0) + 1*(0) + 0*(0) + 2*(1) = 2
	0 0 1 z       0013 ( 0 )     0*(0) + 0*(0) + 1*(0) + 3*(1) = 3
	0 0 0 1       0001 ( 1 )     0*(0) + 0*(0) + 0*(0) + 1*(1) = 1


★크기변환행렬(Scale Matrix) 

x는 2배 y는 그대로 z는 3배 늘리는 행렬
	x 0 0 0      2 0 0 0 ( 2 )      2*(2) + 0*(3) + 0*(5) + 0*(1) = 4 
	0 y 0 0   = 0 1 0 0 ( 3 )  =  0*(2) + 1*(3) + 0*(5) + 0*(1) = 3
	0 0 z 0      0 0 3 0 ( 5 )      0*(2) + 0*(3) + 3*(5) + 0*(1) = 15
	0 0 0 1      0 0 0 1 ( 1 )      0*(2) + 0*(3) + 0*(5) + 1*(1) = 1

(x,y,z,w)에서 w값의 의미
w가 1이면 위치값
w가 0이면 벡터


회전행렬(Rotation Martix) 

       1 0 0 0
       0 1 0 0 
       0 0 1 0
       0 0 0 1

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
모든 3D과정은 그래픽카드에서 처리됌

렌더링 : 3D 오브젝트를 2D 이미로 래스터라이즈 하는 과정

렌더링 파이프라인 : 랜더링 과정의 프로세스를 표현한 것

입력 -> Vertex Shader 
          
          Vertex Shader
          1. 월드 변환(World Transform) : 오브젝트의 로컬 좌표를 월드의 중심점 기준으로 다시 계산하는 것
          2. 카메라 변환(Camera Transform) : 월드의 오브젝트들의 정점 정보를 카메라 기준으로 계산하는 것
                                                     : Eye(위치), LookAt(바라보는 방향), Up(카메라의 위쪽) 
          3. 투영변환(Projection Transform)  : 원근감을 결정하기 위한 변한
                                                     : Frustum View(사각절두체) 안의 오브젝트들을 앞쪽은 늘리고 뒤쪽은 줄여서 
                                                     앞쪽에 있는 오브젝트는 확대 시키고 뒤쪽에 있는 오브젝트는 축소 시킨다.
                                                     : 가로세로 높이가 각각2인 정사각형으로 만듬
       








    
		