변수 : 변하는 숫자. 필요한 데이터를 기록하는 곳
	데이터 타입
	int - 32bit 크기의 정수형(소수점 없는 숫자) 데이터 타입. (-21억~21억)
	float - 32bit 크기의 실수형(소수점 있는 숫자) 데이터 타입. 구조적으로 오차가 있는 데이터 타입이다.
	bool - 1bit 크기의 bool형. true 아니면 false만 가진다.
	string - 문자열을 기록하는 데이터 타입. 크기가 정해져 있지 않다. 변경 불가능한 데이터 타입이다.

접근 제한자(Access Modifier)
    private      : 자기 자신만 접근할 수 있다.
    protected  : 자신과 자신을 상속받은 대상만 접근할 수 있다.
    public       : 모두가 접근 할 수 있다.

부모와 자식 클래스
	public class DumpTruck : Car{}
	Car는 DumpTruck의 부모 클래스
	DumpTruck은 Car의 자식 클래스(파생 클래스)

제어문 : 조건문(if), 반복문(for)

디버거 단축키
F5 : 디버그 시작. 브레이크 포인트에서 계속 진행하기
F9 : 브레이크 포인트 설정
F10 : 한 줄씩 진행하기
F11 : 한 줄씩 진행하기 + 함수면 함수 안으로 들어가기

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★벡터 : 힘의 방향과 크기를 나타내는데 사용
★단위벡터(Unit Vector) : 힘의 방향만 표현하는 벡터. 크기가 *항상 1이다. 벡터를 정규화 해서 만들 수 있다.(Normalized)
★노멀벡터 : 특정 평면에 수직인 벡터. 반사를 계산하는데 *필수. 겉면과 안쪽면을 구분할 수 있게 해준다.

★벡터의 내적(Dot Product) : 벡터와 벡터를 내적했을 때 결과는 *스칼라로 계산된다.
  백터의 내적을 이용해서 두 벡터의 사이각을 구할 수 있다.

★벡터의 외적(Croos Product) : 투 벡터가 이루는 평면에 *수직인 벡터를 계산할 수 있다.
  삼각형의 앞면과 뒷면을 구분할 수 있게 해준다.

카메라가 삼각형을 그릴지 말지를 판단하는 방법은 카메라의 forward 벡터와 삼각형의 
normal벡터의 사이각을 계산해서 예각(0~90도)이면 그리지 않고 둔각이면(90~180도)이면 그린다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★행렬 :  숫자를 행(Row)과 열(Column)을 나누어서 표현한 것.
         행렬과 행렬의 곱은 행렬이 나온다.
         행렬은 *교환법칙이 성립하지 않는다.

Transform(변환) : 위치, 회전, 스케일을 한번에 표현한 것
	          행렬로 표현한다. (변환 행렬)
                      4 * 4 행렬을 사용

단위행렬 : I로 표현(대문자 i)
             대부분의 수는 0이고 왼쪽 위에서 오른쪽 아래로 가는 대각선 부부만 1이다.
             곱하더라도 곱해지는 대상은 항상 변하지 않는다. 
	 단위행렬은 교환법칙이 성립된다.

역행렬 :    -1
           M 
           행렬 M이 있을 때 M과 M의 역행렬을 곱하면 단위행렬이 나온다.

★이동행렬(Translate Matrix)
                         
		 x y z
	            (1,2,3만큼 움직이는 행렬)
	1 0 0 x       1001 ( 0 )     1*(0) + 0*(0) + 0*(0) + 1*(1) = 1 
	0 1 0 y   =  0102 ( 0 )  = 0*(0) + 1*(0) + 0*(0) + 2*(1) = 2
	0 0 1 z       0013 ( 0 )     0*(0) + 0*(0) + 1*(0) + 3*(1) = 3
	0 0 0 1       0001 ( 1 )     0*(0) + 0*(0) + 0*(0) + 1*(1) = 1


★크기변환행렬(Scale Matrix) 

x는 2배 y는 그대로 z는 3배 늘리는 행렬
	x 0 0 0      2 0 0 0 ( 2 )      2*(2) + 0*(3) + 0*(5) + 0*(1) = 4 
	0 y 0 0   = 0 1 0 0 ( 3 )  =  0*(2) + 1*(3) + 0*(5) + 0*(1) = 3
	0 0 z 0      0 0 3 0 ( 5 )      0*(2) + 0*(3) + 3*(5) + 0*(1) = 15
	0 0 0 1      0 0 0 1 ( 1 )      0*(2) + 0*(3) + 0*(5) + 1*(1) = 1

(x,y,z,w)에서 w값의 의미
w가 1이면 위치값
w가 0이면 벡터


회전행렬(Rotation Martix) 

       1 0 0 0
       0 1 0 0 
       0 0 1 0
       0 0 0 1

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
모든 3D과정은 그래픽카드에서 처리됌

렌더링 : 3D 오브젝트를 2D 이미로 래스터라이즈 하는 과정

렌더링 파이프라인 : 랜더링 과정의 프로세스를 표현한 것

입력 -> Vertex Shader 
          
          Vertex Shader
          1. 월드 변환(World Transform) : 오브젝트의 로컬 좌표를 월드의 중심점 기준으로 다시 계산하는 것
          2. 카메라 변환(Camera Transform) : 월드의 오브젝트들의 정점 정보를 카메라 기준으로 계산하는 것
                                                     : Eye(위치), LookAt(바라보는 방향), Up(카메라의 위쪽) 
          3. 투영변환(Projection Transform)  : 원근감을 결정하기 위한 변한
                                                     : Frustum View(사각절두체) 안의 오브젝트들을 앞쪽은 늘리고 뒤쪽은 줄여서 
                                                     앞쪽에 있는 오브젝트는 확대 시키고 뒤쪽에 있는 오브젝트는 축소 시킨다.
                                                     : 가로세로 높이가 각각2인 정사각형으로 만듬

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
  노드(Node)이루워져있음.
  선형 자료구조 : 리스트, 큐, 스택과 같이 자료가 일렬로 나열되는 자료구조
  비선형 자료구조 :  Tree : Root부터 시작하는노드의 집합
                        각 노드는 데이터와 자식을 가짐 

  이진트리(Binary Tree) : 자식이 최대 2개까지 있는 트리
  이진탐색트리(Binary Search Tree) : 이진트리
                                   노드는 Key 값을 가진다, Key는 유일한 것이 매우 권장된다.
                                   모든 노드의 키값은 자신보다 작은 것은 왼쪽에 있고 큰것은 오른쪽에 있다.
                                   트리의 균형이 맞지 않으면 효율이 떨어진다.
  
  힙(Heap) : 트리 구조를 가지고 있다.
             Max heap과 Min heap 두 가지가 있다.
                     우선 순위가 높거나 낮은 것을 처리하는데 유리한 자료 구조
                     Max heap은 root가 가장 큰 키 값을 가진다.
                     Min heap은 root가 가장 작은 키 값을 가진다.
                     
  완전이진트리(Complete Binary Tree) : 한 층씩 채우고 항상 왼쪽에서 오른쪽으로 추가

  그래프(Graph) : 비선형 자료구조 계층구조 없음
                             노드와 엣지로 구성
                             길찾기 알고리즘에서 자주 사용
                             길찾기 알고리즘에서 노드는 위치 또는 장소, 엣지는 장소간의 거리를 나타냄
                             
  길찾기 알고리즘 : 다익스트라 알고리즘(Dijkstra)
                 A* 알고리즘(에이스타 알고리즘) F(x) = g(x) + h(x)
		     
  알고리즘 성능 지표 : 시간복잡도
                               : 알고리즘을 처리하는데 필요한 시간이 얼마나 필요한지 나타내는 개념
                                 빅오 표기법으로 표현가능
                                 O(n), O(n^2), O(n LogN), O(logN)
                                   
                    공간 복잡도
                               : 알고리즘을 처리하는데 필요한 메모리 공간이 얼마나 필요한지 나타내는 개념

  해시 알고리즘 : 데이터를 정해진 길이의 유니크한 요약본으로 만드는 알고리즘
                 결과값으로 원본을 만들수 없어야 한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
  가비지 콜렉션 : 더 이상 사용하지 않는 동적 할당된 메모리
                 쓰레기 모음
                         더 이상 사용하지 않는 메모리를 처리하는 쓰레기통
                         적절한 타이밍에 가비지를 해제
              장점 : 편하다. 프로그래머가 메모리 관리에 더 이상 신경을 쓰지 않게 해준다
              단점 : 프로그래머가 메모리 관리를 못한다. 메모리를 비효율적으로 쓸 수 밖에 없다.

  현재의 컴퓨터 구조 : 폰 노이만 구조

  H/W 구성요소 : CPU, 메모리, 디스크

  메모리 풀 : 메모리를 한번에 크게 할당 받고 프로그램 내부적으로 다시 분배하는 방식
                  운영체제에서 메모리를 할당 받는 작업은 시간이 걸린다.
           한번에 크게 할당받고 프로그램 내부에서 따로 분해처리
                  1. 할당하기에 적합한 메모리 공간을 찾아야 한다.
                  2. 운영체제는 따로 하는 일이 많아 즉시즉시 할당 작업 불가능 
                  

  메모리 단편화 현상 : 메모리를 자주 할당받고 해제하다보면 사용하기 힘든 작은 메모리 파편들이 생기는 현상
                               실제 남아있는 메모리를 다 활용할 수 없게 됨
                               피하기 위한 방법 : 할당할 때 2^n크기로 할당하면 단편화 현상을 줄일 수 있다.

  오브젝트 풀 : 오브젝트를 한번에 많이 생성해 놓은 후. 오브젝트가 필요할 때 활성화 시켜서 사용하는 방식 필요없어지면 
                      비활성화해서 나중에 다시 사용할수 있게함
	
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
높이맵(Heght map) : 지형을 표한하기 위한 기법 중 하나
                                매우 적은 용량으로 큰 지형이 표현 가능
             단점 : 동굴이나 절벽같이 높이가 겹치는 지형은 표현 불가능

심리스(Seamless) : 내가 바로 갈 수 있거나 볼 수 있는 지역은 전부 로딩을하고
                               내가 갈 수도 있는 지역은 백그라운드에서 미리 로딩해놓고
                               내가 절대로 갈 수 없는 지역은 백그라운드에서 로딩을 해제하는 기법
                               유저 입장에서는 처음 한번만 로딩이 있는 것으로 느끼게 만들 수 있다.







    
		